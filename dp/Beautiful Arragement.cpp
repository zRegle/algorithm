/**
 * Leetcode 526. 优美的排列
 * 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，
 * 使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，
 * 我们就称这个数组为一个优美的排列。条件：
 *  (1)第 i 位的数字能被 i 整除
 *  (2)i 能被第 i 位上的数字整除
 *
 * 现在给定一个整数 N，请问可以构造多少个优美的排列？
 *
 * 示例1:
 * 输入: 2
 * 输出: 2
 * 解释:
 *  第 1 个优美的排列是 [1, 2]:
 *   第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
 *   第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除
 *  第 2 个优美的排列是 [2, 1]:
 *   第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
 *   第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
 */
#include <vector>
using std::vector;

/**
 * from leetcode: 状态压缩dp
 * 
 * 用一个n位的二进制数表示二进制中为1的数字已任意顺序放在数组的前m位(m为该二进制数中1的个数)
 * 例如0b010101, 第1,3,5位是1，一共3个1，所以表示1,3,5以任意顺序放在数组前3位
 *
 * 状态：dp[n]表示二进制数n代表的所有排列中有效情况的数量
 * 更新状态：对于二进制中为0的代表数字j，判断其是否可以作为下一个放入数组中的数，
 *          若是则更新dp[n | (1 << (j-1))] += dp[n]
 *
 * 例子：0b010101中，第2位为0，判断其是否可放在数组第4位（因为数组已有3个数），
 * 显然可以（4 % 2 == 0），更新dp[0b010101 | (1 << (2-1))] += dp[0b010101];
 * 即dp[0b010111] += dp[0b010101];
 *
 * 即dp[二进制中有(k+1)位1] = ∑ dp[二进制中有k位1]
 */
#define GET(x, idx) (x & (1 << (idx - 1))) /* 获取第idx位的bit */
#define SET(x, idx) (x | (1 << (idx - 1))) /* 设置第idx位的bit为1 */
class Solution {
public:
    int countArrangement(int n) {
        vector<int> dp(1 << n, 0);
        for (int i = 0; i < n; i++) {
            /* 每个数都能放在第1位 */
            dp[1 << i] = 1;
        }
        for (int i = 0; i < (1 << n); i++) {
            int index = 1;
            int tmp = i;
            /* 统计有多少个1 */
            while (tmp) {
                tmp &= tmp - 1; /* 最低位的1置0 */
                index++;
            }
            for (int j = 1; j <= n; j++) {
                if (j % index == 0 || index % j == 0) {
                    /* j能放在第index位 */
                    if (GET(i, j) == 0)
                        /* 并且j没选取过 */
                        dp[SET(i, j)] += dp[i];
                }
            }
        }
        /* (1 << n) - 1就是有n个1
         * 代表n个数任意顺序存放在前n个位置的有效排列数量
         */
        return dp[(1 << n) - 1];
    }
};